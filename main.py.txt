"""
UPDATED_RICH PRO Signals - Production-ready payment gate (use env vars for secrets)

Required environment variables on Render:
- BOT_TOKEN
- PAYSTACK_PUBLIC_KEY
- PAYSTACK_SECRET_KEY
- PUBLIC_BASE_URL (e.g. https://updated-rich-pro-bot-1.onrender.com)
- ADMIN_TELEGRAM_ID (your numeric Telegram id)
- SIGNAL_BOT_USERNAME (e.g. minesprosignal_bot)
- SUBSCRIPTION_AMOUNT_GHS (default 60)
- SUBSCRIPTION_DISPLAY_AMOUNT (default $5.00)
- SUB_DAYS (default 10)
"""
import os
import time
import hmac
import hashlib
import secrets
import sqlite3
from threading import Thread
from urllib.parse import quote_plus

import requests
from flask import Flask, request, jsonify, send_file
from telegram import Bot, InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import Dispatcher, CommandHandler, CallbackContext

# ---------- CONFIG ----------
BOT_TOKEN = os.environ.get('BOT_TOKEN')
PAYSTACK_PUBLIC_KEY = os.environ.get('PAYSTACK_PUBLIC_KEY')
PAYSTACK_SECRET_KEY = os.environ.get('PAYSTACK_SECRET_KEY')
PUBLIC_BASE_URL = os.environ.get('PUBLIC_BASE_URL')
ADMIN_TELEGRAM_ID = int(os.environ.get('ADMIN_TELEGRAM_ID', '0'))
SIGNAL_BOT_USERNAME = os.environ.get('SIGNAL_BOT_USERNAME', 'minesprosignal_bot')

SUBSCRIPTION_AMOUNT_GHS = int(os.environ.get('SUBSCRIPTION_AMOUNT_GHS', '60'))
SUBSCRIPTION_DISPLAY_AMOUNT = os.environ.get('SUBSCRIPTION_DISPLAY_AMOUNT', '$5.00')
SUB_DAYS = int(os.environ.get('SUB_DAYS', '10'))

# Basic safety checks
if not BOT_TOKEN:
    raise RuntimeError('BOT_TOKEN not set')
if not PUBLIC_BASE_URL:
    raise RuntimeError('PUBLIC_BASE_URL not set')

app = Flask(__name__)
bot = Bot(token=BOT_TOKEN)
dispatcher = Dispatcher(bot, None, workers=0, use_context=True)

DB_PATH = 'payments.db'


def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS payments (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        telegram_id INTEGER,
        username TEXT,
        amount INTEGER,
        currency TEXT,
        reference TEXT UNIQUE,
        paid_at INTEGER,
        expiry INTEGER,
        ip_address TEXT,
        token TEXT
    )''')
    conn.commit()
    conn.close()


def add_payment(telegram_id, username, amount, currency, reference, paid_at, expiry, ip_address, token):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('INSERT OR IGNORE INTO payments (telegram_id, username, amount, currency, reference, paid_at, expiry, ip_address, token) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
              (telegram_id, username, amount, currency, reference, paid_at, expiry, ip_address, token))
    conn.commit()
    conn.close()


def get_active(telegram_id):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    now = int(time.time())
    c.execute('SELECT expiry FROM payments WHERE telegram_id = ? ORDER BY paid_at DESC LIMIT 1', (telegram_id,))
    row = c.fetchone()
    conn.close()
    if not row:
        return False
    return now < row[0]


# ---------- Flask routes ----------
@app.route('/')
def home():
    return 'UPDATED_RICH PRO Signals ‚Äî Payment gate running', 200


@app.route('/banner.png')
def banner():
    return send_file('banner.png', mimetype='image/png')


@app.route('/payment-success')
def payment_success():
    return '<html><body><h2>Payment completed ‚Äî return to Telegram.</h2></body></html>'


def verify_paystack_signature(request_body_bytes, signature_header):
    if not PAYSTACK_SECRET_KEY:
        return False
    if not signature_header:
        return False
    computed = hmac.new(PAYSTACK_SECRET_KEY.encode(), request_body_bytes, hashlib.sha512).hexdigest()
    return hmac.compare_digest(computed, signature_header)


@app.route('/paystack/webhook', methods=['POST'])
def paystack_webhook():
    raw = request.get_data()
    sig = request.headers.get('x-paystack-signature')
    if not verify_paystack_signature(raw, sig):
        return 'invalid signature', 400
    data = request.json or {}
    if data.get('event') == 'charge.success':
        pdata = data.get('data', {})
        ref = pdata.get('reference')
        amount = pdata.get('amount')
        currency = pdata.get('currency')
        metadata = pdata.get('metadata') or {}
        telegram_id = int(metadata.get('telegram_id')) if metadata.get('telegram_id') else None
        paid_at = int(time.time())
        expiry = paid_at + SUB_DAYS * 24 * 3600
        ip_addr = request.remote_addr
        token = secrets.token_urlsafe(12)
        add_payment(telegram_id, metadata.get('username') or '', amount, currency, ref, paid_at, expiry, ip_addr, token)
        deep = f"https://t.me/{SIGNAL_BOT_USERNAME}?start={quote_plus(token)}"
        try:
            bot.send_message(chat_id=telegram_id, text='‚úÖ Payment confirmed ‚Äî connecting you now...')
            kb = [[InlineKeyboardButton('üîì Open signal bot', url=deep)]]
            bot.send_message(chat_id=telegram_id, text='Tap to open your signal bot:', reply_markup=InlineKeyboardMarkup(kb))
        except Exception as e:
            app.logger.exception('Failed to message user: %s', e)
    return jsonify({'status': 'ok'})


# ---------- Telegram webhook endpoint ----------
@app.route('/webhook', methods=['POST'])
def telegram_webhook():
    update = request.get_json(force=True, silent=True)
    if update is None:
        return 'no update', 400
    try:
        dispatcher.process_update(Update.de_json(update, bot))
    except Exception as e:
        app.logger.exception('Failed to process update: %s', e)
    return 'OK', 200


# ---------- Telegram command handlers ----------
def start_handler(update: Update, context: CallbackContext):
    user = update.effective_user
    tid = user.id
    msg = (
        'üíé *Welcome to UPDATED_RICH PRO Signals!*\\n'
        'Win Smarter ‚Äî You are connected successfully. Type /help to see commands.'
    )
    try:
        with open('banner.png', 'rb') as f:
            context.bot.send_photo(chat_id=tid, photo=f, caption=msg, parse_mode='Markdown')
    except Exception:
        context.bot.send_message(chat_id=tid, text=msg, parse_mode='Markdown')


def help_handler(update: Update, context: CallbackContext):
    tid = update.effective_user.id
    help_text = (
        '/start - start the bot\\n'
        '/help - show this help\\n'
        '/pay - get payment link\\n'
        '/status - check subscription status\\n'
    )
    context.bot.send_message(chat_id=tid, text=help_text)


def pay_handler(update: Update, context: CallbackContext):
    tid = update.effective_user.id
    headers = {'Authorization': f'Bearer {PAYSTACK_SECRET_KEY}'} if PAYSTACK_SECRET_KEY else {}
    payload = {'email': f'{tid}@example.com', 'amount': int(SUBSCRIPTION_AMOUNT_GHS * 100), 'currency': 'GHS', 'callback_url': f'{PUBLIC_BASE_URL}/payment-success', 'metadata': {'telegram_id': tid}}
    try:
        if PAYSTACK_SECRET_KEY:
            r = requests.post('https://api.paystack.co/transaction/initialize', headers=headers, json=payload, timeout=20)
            r.raise_for_status()
            data = r.json()
            pay_url = data.get('data', {}).get('authorization_url')
        else:
            pay_url = f'{PUBLIC_BASE_URL}/payment-success'
    except Exception:
        pay_url = f'{PUBLIC_BASE_URL}/payment-success'
    kb = [[InlineKeyboardButton(f'üí≥ Pay {SUBSCRIPTION_DISPLAY_AMOUNT} (‚Çµ{SUBSCRIPTION_AMOUNT_GHS})', url=pay_url)]]
    context.bot.send_message(chat_id=tid, text='Click the button below to pay:', reply_markup=InlineKeyboardMarkup(kb))


def status_handler(update: Update, context: CallbackContext):
    tid = update.effective_user.id
    active = get_active(tid)
    if active:
        context.bot.send_message(chat_id=tid, text='‚úÖ Your access is active.')
    else:
        context.bot.send_message(chat_id=tid, text='‚ùå No active access. Use /pay to subscribe.')


dispatcher.add_handler(CommandHandler('start', start_handler))
dispatcher.add_handler(CommandHandler('help', help_handler))
dispatcher.add_handler(CommandHandler('pay', pay_handler))
dispatcher.add_handler(CommandHandler('status', status_handler))

if __name__ == '__main__':
    init_db()

    def expiration_loop():
        while True:
            conn = sqlite3.connect(DB_PATH)
            c = conn.cursor()
            now = int(time.time())
            c.execute('SELECT telegram_id FROM payments WHERE expiry <= ? AND expiry > 0', (now,))
            rows = c.fetchall()
            for r in rows:
                tid = r[0]
                try:
                    kb = [[InlineKeyboardButton('üîÅ Renew', url=f'{PUBLIC_BASE_URL}/payment-success')]]
                    bot.send_message(chat_id=tid, text='‚è≥ Your access has ended. Tap to renew.', reply_markup=InlineKeyboardMarkup(kb))
                    c.execute('UPDATE payments SET expiry = 0 WHERE telegram_id = ?', (tid,))
                except Exception:
                    pass
            conn.commit()
            conn.close()
            time.sleep(3600)

    Thread(target=expiration_loop, daemon=True).start()
    app.run(host='0.0.0.0', port=int(os.environ.get('PORT', 10000)))
